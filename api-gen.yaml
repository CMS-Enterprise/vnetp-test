swagger: '2.0'
info:
    description: 'Draas OAS Documentation'
    version: 0.0.1
    title: Draas
basePath: /
tags:
    - {name: app, description: ""}
schemes:
    - http
paths:
    /datacenters: {get: {summary: 'Retrieve many Datacenter', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Datacenter'}}}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one Datacenter', parameters: [{name: Datacenter, required: true, in: body, schema: {$ref: '#/definitions/Datacenter'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/Datacenter'}}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}}
    '/datacenters/{id}': {get: {summary: 'Retrieve one Datacenter', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Datacenter'}}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one Datacenter', parameters: [{name: Datacenter, required: true, in: body, schema: {$ref: '#/definitions/Datacenter'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Datacenter'}}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one Datacenter', parameters: [{name: Datacenter, required: true, in: body, schema: {$ref: '#/definitions/Datacenter'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Datacenter'}}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one Datacenter', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Datacenter'}}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}}
    /datacenters/bulk: {post: {summary: 'Create many Datacenter', parameters: [{name: GeneratedDatacenterBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedDatacenterBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/Datacenter'}}}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}}
    '/datacenters/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}}
    '/datacenters/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [datacenters], produces: [application/json], consumes: [application/json]}}
    '/datacenters/{datacenterId}/tiers': {get: {summary: 'Retrieve many Tier', parameters: [{name: datacenterId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Tier'}}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    '/datacenters/{datacenterId}/tiers/{id}': {get: {summary: 'Retrieve one Tier', parameters: [{name: id, required: true, in: path, type: string}, {name: datacenterId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Tier'}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    /tiers: {get: {summary: 'Retrieve many Tier', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Tier'}}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one Tier', parameters: [{name: Tier, required: true, in: body, schema: {$ref: '#/definitions/Tier'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/Tier'}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    '/tiers/{id}': {get: {summary: 'Retrieve one Tier', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Tier'}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one Tier', parameters: [{name: Tier, required: true, in: body, schema: {$ref: '#/definitions/Tier'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Tier'}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one Tier', parameters: [{name: Tier, required: true, in: body, schema: {$ref: '#/definitions/Tier'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Tier'}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one Tier', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Tier'}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    /tiers/bulk: {post: {summary: 'Create many Tier', parameters: [{name: GeneratedTierBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedTierBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/Tier'}}}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    '/tiers/{id}/provision': {put: {summary: 'Provisions an Entity.', responses: {'200': {description: ""}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    '/tiers/{id}/deprovision': {patch: {summary: 'Deprovisions an Entity.', responses: {'200': {description: ""}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    '/tiers/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    '/tiers/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [tiers], produces: [application/json], consumes: [application/json]}}
    /network-security/firewall-rule-groups: {get: {summary: 'Retrieve many FirewallRuleGroup', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/FirewallRuleGroup'}}}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one FirewallRuleGroup', parameters: [{name: FirewallRuleGroup, required: true, in: body, schema: {$ref: '#/definitions/FirewallRuleGroup'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/FirewallRuleGroup'}}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rule-groups/{id}': {get: {summary: 'Retrieve one FirewallRuleGroup', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRuleGroup'}}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one FirewallRuleGroup', parameters: [{name: FirewallRuleGroup, required: true, in: body, schema: {$ref: '#/definitions/FirewallRuleGroup'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRuleGroup'}}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one FirewallRuleGroup', parameters: [{name: FirewallRuleGroup, required: true, in: body, schema: {$ref: '#/definitions/FirewallRuleGroup'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRuleGroup'}}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one FirewallRuleGroup', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRuleGroup'}}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}}
    /network-security/firewall-rule-groups/bulk: {post: {summary: 'Create many FirewallRuleGroup', parameters: [{name: GeneratedFirewallRuleGroupBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedFirewallRuleGroupBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/FirewallRuleGroup'}}}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rule-groups/{id}/provision': {put: {summary: 'Provisions an Entity.', responses: {'200': {description: ""}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rule-groups/{id}/deprovision': {patch: {summary: 'Deprovisions an Entity.', responses: {'200': {description: ""}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rule-groups/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rule-groups/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network-security/firewall-rule-groups], produces: [application/json], consumes: [application/json]}}
    /network-security/firewall-rules: {get: {summary: 'Retrieve many FirewallRule', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/FirewallRule'}}}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one FirewallRule', parameters: [{name: FirewallRule, required: true, in: body, schema: {$ref: '#/definitions/FirewallRule'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/FirewallRule'}}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rules/{id}': {get: {summary: 'Retrieve one FirewallRule', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRule'}}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one FirewallRule', parameters: [{name: FirewallRule, required: true, in: body, schema: {$ref: '#/definitions/FirewallRule'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRule'}}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one FirewallRule', parameters: [{name: FirewallRule, required: true, in: body, schema: {$ref: '#/definitions/FirewallRule'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRule'}}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one FirewallRule', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/FirewallRule'}}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}}
    /network-security/firewall-rules/bulk: {post: {summary: 'Create many FirewallRule', parameters: [{name: GeneratedFirewallRuleBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedFirewallRuleBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/FirewallRule'}}}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rules/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}}
    '/network-security/firewall-rules/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network-security/firewall-rules], produces: [application/json], consumes: [application/json]}}
    /network-security/network-objects: {get: {summary: 'Retrieve many NetworkObject', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/NetworkObject'}}}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one NetworkObject', parameters: [{name: NetworkObject, required: true, in: body, schema: {$ref: '#/definitions/NetworkObject'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/NetworkObject'}}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}}
    '/network-security/network-objects/{id}': {get: {summary: 'Retrieve one NetworkObject', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObject'}}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one NetworkObject', parameters: [{name: NetworkObject, required: true, in: body, schema: {$ref: '#/definitions/NetworkObject'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObject'}}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one NetworkObject', parameters: [{name: NetworkObject, required: true, in: body, schema: {$ref: '#/definitions/NetworkObject'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObject'}}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one NetworkObject', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObject'}}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}}
    /network-security/network-objects/bulk: {post: {summary: 'Create many NetworkObject', parameters: [{name: GeneratedNetworkObjectBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedNetworkObjectBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/NetworkObject'}}}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}}
    '/network-security/network-objects/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}}
    '/network-security/network-objects/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network-security/network-objects], produces: [application/json], consumes: [application/json]}}
    /network-security/network-object-groups: {get: {summary: 'Retrieve many NetworkObjectGroup', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/NetworkObjectGroup'}}}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one NetworkObjectGroup', parameters: [{name: NetworkObjectGroup, required: true, in: body, schema: {$ref: '#/definitions/NetworkObjectGroup'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/NetworkObjectGroup'}}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/network-object-groups/{id}': {get: {summary: 'Retrieve one NetworkObjectGroup', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObjectGroup'}}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one NetworkObjectGroup', parameters: [{name: NetworkObjectGroup, required: true, in: body, schema: {$ref: '#/definitions/NetworkObjectGroup'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObjectGroup'}}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one NetworkObjectGroup', parameters: [{name: NetworkObjectGroup, required: true, in: body, schema: {$ref: '#/definitions/NetworkObjectGroup'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObjectGroup'}}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one NetworkObjectGroup', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/NetworkObjectGroup'}}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}}
    /network-security/network-object-groups/bulk: {post: {summary: 'Create many NetworkObjectGroup', parameters: [{name: GeneratedNetworkObjectGroupBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedNetworkObjectGroupBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/NetworkObjectGroup'}}}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/network-object-groups/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/network-object-groups/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network-security/network-object-groups], produces: [application/json], consumes: [application/json]}}
    /network-security/service-objects: {get: {summary: 'Retrieve many ServiceObject', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/ServiceObject'}}}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one ServiceObject', parameters: [{name: ServiceObject, required: true, in: body, schema: {$ref: '#/definitions/ServiceObject'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/ServiceObject'}}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}}
    '/network-security/service-objects/{id}': {get: {summary: 'Retrieve one ServiceObject', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObject'}}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one ServiceObject', parameters: [{name: ServiceObject, required: true, in: body, schema: {$ref: '#/definitions/ServiceObject'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObject'}}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one ServiceObject', parameters: [{name: ServiceObject, required: true, in: body, schema: {$ref: '#/definitions/ServiceObject'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObject'}}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one ServiceObject', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObject'}}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}}
    /network-security/service-objects/bulk: {post: {summary: 'Create many ServiceObject', parameters: [{name: GeneratedServiceObjectBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedServiceObjectBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/ServiceObject'}}}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}}
    '/network-security/service-objects/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}}
    '/network-security/service-objects/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network-security/service-objects], produces: [application/json], consumes: [application/json]}}
    /network-security/service-object-groups: {get: {summary: 'Retrieve many ServiceObjectGroup', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/ServiceObjectGroup'}}}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one ServiceObjectGroup', parameters: [{name: ServiceObjectGroup, required: true, in: body, schema: {$ref: '#/definitions/ServiceObjectGroup'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/ServiceObjectGroup'}}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/service-object-groups/{id}': {get: {summary: 'Retrieve one ServiceObjectGroup', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObjectGroup'}}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one ServiceObjectGroup', parameters: [{name: ServiceObjectGroup, required: true, in: body, schema: {$ref: '#/definitions/ServiceObjectGroup'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObjectGroup'}}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one ServiceObjectGroup', parameters: [{name: ServiceObjectGroup, required: true, in: body, schema: {$ref: '#/definitions/ServiceObjectGroup'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObjectGroup'}}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one ServiceObjectGroup', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/ServiceObjectGroup'}}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}}
    /network-security/service-object-groups/bulk: {post: {summary: 'Create many ServiceObjectGroup', parameters: [{name: GeneratedServiceObjectGroupBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedServiceObjectGroupBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/ServiceObjectGroup'}}}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/service-object-groups/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}}
    '/network-security/service-object-groups/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network-security/service-object-groups], produces: [application/json], consumes: [application/json]}}
    '/tiers/{tierId}/vlans': {get: {summary: 'Retrieve many Vlan', parameters: [{name: tierId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Vlan'}}}}, tags: [vlans], produces: [application/json], consumes: [application/json]}}
    '/tiers/{tierId}/vlans/{id}': {get: {summary: 'Retrieve one Vlan', parameters: [{name: id, required: true, in: path, type: string}, {name: tierId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Vlan'}}}, tags: [vlans], produces: [application/json], consumes: [application/json]}}
    /network/vlans: {get: {summary: 'Retrieve many Vlan', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Vlan'}}}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one Vlan', parameters: [{name: Vlan, required: true, in: body, schema: {$ref: '#/definitions/Vlan'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/Vlan'}}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}}
    '/network/vlans/{id}': {get: {summary: 'Retrieve one Vlan', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Vlan'}}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one Vlan', parameters: [{name: Vlan, required: true, in: body, schema: {$ref: '#/definitions/Vlan'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Vlan'}}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one Vlan', parameters: [{name: Vlan, required: true, in: body, schema: {$ref: '#/definitions/Vlan'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Vlan'}}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one Vlan', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Vlan'}}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}}
    /network/vlans/bulk: {post: {summary: 'Create many Vlan', parameters: [{name: GeneratedVlanBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedVlanBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/Vlan'}}}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}}
    '/network/vlans/{id}/provision': {put: {summary: 'Provisions an Entity.', responses: {'200': {description: ""}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}}
    '/network/vlans/{id}/deprovision': {patch: {summary: 'Deprovisions an Entity.', responses: {'200': {description: ""}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}}
    '/network/vlans/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}}
    '/network/vlans/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network/vlans], produces: [application/json], consumes: [application/json]}}
    '/vlans/{vlanId}/subnets': {get: {summary: 'Retrieve many Subnet', parameters: [{name: vlanId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Subnet'}}}}, tags: [subnets], produces: [application/json], consumes: [application/json]}}
    '/vlans/{vlanId}/subnets/{id}': {get: {summary: 'Retrieve one Subnet', parameters: [{name: id, required: true, in: path, type: string}, {name: vlanId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Subnet'}}}, tags: [subnets], produces: [application/json], consumes: [application/json]}}
    '/tiers/{tierId}/subnets': {get: {summary: 'Retrieve many Subnet', parameters: [{name: vlanId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Subnet'}}}}, tags: [subnets], produces: [application/json], consumes: [application/json]}}
    '/tiers/{tierId}/subnets/{id}': {get: {summary: 'Retrieve one Subnet', parameters: [{name: id, required: true, in: path, type: string}, {name: vlanId, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Subnet'}}}, tags: [subnets], produces: [application/json], consumes: [application/json]}}
    /network/subnets: {get: {summary: 'Retrieve many Subnet', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Subnet'}}}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one Subnet', parameters: [{name: Subnet, required: true, in: body, schema: {$ref: '#/definitions/Subnet'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/Subnet'}}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}}
    '/network/subnets/{id}': {get: {summary: 'Retrieve one Subnet', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Subnet'}}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one Subnet', parameters: [{name: Subnet, required: true, in: body, schema: {$ref: '#/definitions/Subnet'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Subnet'}}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one Subnet', parameters: [{name: Subnet, required: true, in: body, schema: {$ref: '#/definitions/Subnet'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Subnet'}}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one Subnet', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Subnet'}}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}}
    /network/subnets/bulk: {post: {summary: 'Create many Subnet', parameters: [{name: GeneratedSubnetBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedSubnetBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/Subnet'}}}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}}
    '/network/subnets/{id}/provision': {put: {summary: 'Provisions an Entity.', responses: {'200': {description: ""}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}}
    '/network/subnets/{id}/deprovision': {patch: {summary: 'Deprovisions an Entity.', responses: {'200': {description: ""}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}}
    '/network/subnets/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}}
    '/network/subnets/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network/subnets], produces: [application/json], consumes: [application/json]}}
    /network/static-routes: {get: {summary: 'Retrieve many StaticRoute', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/StaticRoute'}}}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one StaticRoute', parameters: [{name: StaticRoute, required: true, in: body, schema: {$ref: '#/definitions/StaticRoute'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/StaticRoute'}}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}}
    '/network/static-routes/{id}': {get: {summary: 'Retrieve one StaticRoute', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/StaticRoute'}}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one StaticRoute', parameters: [{name: StaticRoute, required: true, in: body, schema: {$ref: '#/definitions/StaticRoute'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/StaticRoute'}}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one StaticRoute', parameters: [{name: StaticRoute, required: true, in: body, schema: {$ref: '#/definitions/StaticRoute'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/StaticRoute'}}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one StaticRoute', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/StaticRoute'}}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}}
    /network/static-routes/bulk: {post: {summary: 'Create many StaticRoute', parameters: [{name: GeneratedStaticRouteBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedStaticRouteBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/StaticRoute'}}}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}}
    '/network/static-routes/{id}/provision': {put: {summary: 'Provisions an Entity.', responses: {'200': {description: ""}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}}
    '/network/static-routes/{id}/deprovision': {patch: {summary: 'Deprovisions an Entity.', responses: {'200': {description: ""}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}}
    '/network/static-routes/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}}
    '/network/static-routes/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [network/static-routes], produces: [application/json], consumes: [application/json]}}
    /auth/login: {post: {parameters: [{name: User, required: true, in: body, schema: {$ref: '#/definitions/User'}}], responses: {'201': {description: ""}}, produces: [application/json], consumes: [application/json]}}
    /auth/register: {post: {parameters: [{name: User, required: true, in: body, schema: {$ref: '#/definitions/User'}}], responses: {'201': {description: ""}}, produces: [application/json], consumes: [application/json]}}
    /vmware/virtual-machines: {get: {summary: 'Retrieve many VmwareVirtualMachine', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/VmwareVirtualMachine'}}}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one VmwareVirtualMachine', parameters: [{name: VmwareVirtualMachine, required: true, in: body, schema: {$ref: '#/definitions/VmwareVirtualMachine'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/VmwareVirtualMachine'}}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-machines/{id}': {get: {summary: 'Retrieve one VmwareVirtualMachine', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualMachine'}}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one VmwareVirtualMachine', parameters: [{name: VmwareVirtualMachine, required: true, in: body, schema: {$ref: '#/definitions/VmwareVirtualMachine'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualMachine'}}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one VmwareVirtualMachine', parameters: [{name: VmwareVirtualMachine, required: true, in: body, schema: {$ref: '#/definitions/VmwareVirtualMachine'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualMachine'}}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one VmwareVirtualMachine', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualMachine'}}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}}
    /vmware/virtual-machines/bulk: {post: {summary: 'Create many VmwareVirtualMachine', parameters: [{name: GeneratedVmwareVirtualMachineBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedVmwareVirtualMachineBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/VmwareVirtualMachine'}}}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-machines/{id}/provision': {put: {summary: 'Provisions an Entity.', responses: {'200': {description: ""}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-machines/{id}/deprovision': {patch: {summary: 'Deprovisions an Entity.', responses: {'200': {description: ""}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-machines/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-machines/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [vmware/virtual-machines], produces: [application/json], consumes: [application/json]}}
    /vmware/network-adapter: {get: {summary: 'Retrieve many VmwareNetworkAdapter', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/VmwareNetworkAdapter'}}}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one VmwareNetworkAdapter', parameters: [{name: VmwareNetworkAdapter, required: true, in: body, schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}}
    '/vmware/network-adapter/{id}': {get: {summary: 'Retrieve one VmwareNetworkAdapter', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one VmwareNetworkAdapter', parameters: [{name: VmwareNetworkAdapter, required: true, in: body, schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one VmwareNetworkAdapter', parameters: [{name: VmwareNetworkAdapter, required: true, in: body, schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one VmwareNetworkAdapter', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareNetworkAdapter'}}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}}
    /vmware/network-adapter/bulk: {post: {summary: 'Create many VmwareNetworkAdapter', parameters: [{name: GeneratedVmwareNetworkAdapterBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedVmwareNetworkAdapterBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/VmwareNetworkAdapter'}}}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}}
    '/vmware/network-adapter/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}}
    '/vmware/network-adapter/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [vmware/network-adapter], produces: [application/json], consumes: [application/json]}}
    /vmware/virtual-disks: {get: {summary: 'Retrieve many VmwareVirtualDisk', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/VmwareVirtualDisk'}}}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one VmwareVirtualDisk', parameters: [{name: VmwareVirtualDisk, required: true, in: body, schema: {$ref: '#/definitions/VmwareVirtualDisk'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/VmwareVirtualDisk'}}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-disks/{id}': {get: {summary: 'Retrieve one VmwareVirtualDisk', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualDisk'}}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one VmwareVirtualDisk', parameters: [{name: VmwareVirtualDisk, required: true, in: body, schema: {$ref: '#/definitions/VmwareVirtualDisk'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualDisk'}}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one VmwareVirtualDisk', parameters: [{name: VmwareVirtualDisk, required: true, in: body, schema: {$ref: '#/definitions/VmwareVirtualDisk'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualDisk'}}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one VmwareVirtualDisk', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/VmwareVirtualDisk'}}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}}
    /vmware/virtual-disks/bulk: {post: {summary: 'Create many VmwareVirtualDisk', parameters: [{name: GeneratedVmwareVirtualDiskBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedVmwareVirtualDiskBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/VmwareVirtualDisk'}}}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-disks/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}}
    '/vmware/virtual-disks/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [vmware/virtual-disks], produces: [application/json], consumes: [application/json]}}
    /physical-servers: {get: {summary: 'Retrieve many PhysicalServer', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/PhysicalServer'}}}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one PhysicalServer', parameters: [{name: PhysicalServer, required: true, in: body, schema: {$ref: '#/definitions/PhysicalServer'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/PhysicalServer'}}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}}
    '/physical-servers/{id}': {get: {summary: 'Retrieve one PhysicalServer', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/PhysicalServer'}}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one PhysicalServer', parameters: [{name: PhysicalServer, required: true, in: body, schema: {$ref: '#/definitions/PhysicalServer'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/PhysicalServer'}}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one PhysicalServer', parameters: [{name: PhysicalServer, required: true, in: body, schema: {$ref: '#/definitions/PhysicalServer'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/PhysicalServer'}}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one PhysicalServer', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/PhysicalServer'}}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}}
    /physical-servers/bulk: {post: {summary: 'Create many PhysicalServer', parameters: [{name: GeneratedPhysicalServerBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedPhysicalServerBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/PhysicalServer'}}}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}}
    '/physical-servers/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}}
    '/physical-servers/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [physical-servers], produces: [application/json], consumes: [application/json]}}
    /appliances: {get: {summary: 'Retrieve many Appliance', parameters: [{name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: filter, description: '<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter=name||eq||batman</strong></li><li><strong>?filter=isVillain||eq||false&filter=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter=power||isnull</strong> (some conditions don''t accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn''t accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>', required: false, in: query, type: string}, {name: or, description: '<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter=name||eq||batman&or=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter=type||eq||hero&filter=status||eq||alive&or=type||eq||villain&or=status||eq||dead</strong></li></ul></ul>', required: false, in: query, type: string}, {name: sort, description: '<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort=name,ASC</strong></li><li><strong>?sort=name,ASC&sort=id,DESC</strong></li></ul>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: per_page, description: '<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>', required: false, in: query, type: number}, {name: offset, description: '<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>', required: false, in: query, type: number}, {name: page, description: '<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>', required: false, in: query, type: number}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {type: array, items: {$ref: '#/definitions/Appliance'}}}}, tags: [appliances], produces: [application/json], consumes: [application/json]}, post: {summary: 'Create one Appliance', parameters: [{name: Appliance, required: true, in: body, schema: {$ref: '#/definitions/Appliance'}}], responses: {'201': {description: "", schema: {$ref: '#/definitions/Appliance'}}}, tags: [appliances], produces: [application/json], consumes: [application/json]}}
    '/appliances/{id}': {get: {summary: 'Retrieve one Appliance', parameters: [{name: id, required: true, in: path, type: string}, {name: fields, description: '<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>', required: false, in: query, type: string}, {name: join, description: '<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join=relation</strong></li><li><strong>?join=relation||field1,field2,...</strong></li><li><strong>?join=relation1||field11,field12,...&join=relation1.nested||field21,field22,...&join=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join=profile</strong></li><li><strong>?join=profile||firstName,email</strong></li><li><strong>?join=profile||firstName,email&join=notifications||content&join=tasks</strong></li><li><strong>?join=relation1&join=relation1.nested&join=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.', required: false, in: query, type: string}, {name: cache, description: '<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>', required: false, in: query, type: number}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Appliance'}}}, tags: [appliances], produces: [application/json], consumes: [application/json]}, patch: {summary: 'Update one Appliance', parameters: [{name: Appliance, required: true, in: body, schema: {$ref: '#/definitions/Appliance'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Appliance'}}}, tags: [appliances], produces: [application/json], consumes: [application/json]}, put: {summary: 'Replace one Appliance', parameters: [{name: Appliance, required: true, in: body, schema: {$ref: '#/definitions/Appliance'}}, {name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Appliance'}}}, tags: [appliances], produces: [application/json], consumes: [application/json]}, delete: {summary: 'Delete one Appliance', parameters: [{name: id, required: true, in: path, type: string}], responses: {'200': {description: "", schema: {$ref: '#/definitions/Appliance'}}}, tags: [appliances], produces: [application/json], consumes: [application/json]}}
    /appliances/bulk: {post: {summary: 'Create many Appliance', parameters: [{name: GeneratedApplianceBulkDto, required: true, in: body, schema: {$ref: '#/definitions/GeneratedApplianceBulkDto'}}], responses: {'201': {description: "", schema: {type: array, items: {$ref: '#/definitions/Appliance'}}}}, tags: [appliances], produces: [application/json], consumes: [application/json]}}
    '/appliances/{id}/soft': {delete: {summary: 'Soft deletes an Entity.', responses: {'200': {description: ""}}, tags: [appliances], produces: [application/json], consumes: [application/json]}}
    '/appliances/{id}/restore': {patch: {summary: 'Restores a Soft-Deleted Entity.', responses: {'200': {description: ""}}, tags: [appliances], produces: [application/json], consumes: [application/json]}}
definitions:
    Date: {type: object, properties: {}}
    Datacenter: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}}, required: [name]}
    GeneratedDatacenterBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/Datacenter'}}}, required: [bulk]}
    Tier: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, datacenterId: {type: string}}, required: [name, datacenterId]}
    GeneratedTierBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/Tier'}}}, required: [bulk]}
    FirewallRuleGroup: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, type: {type: string}, tierId: {type: string}}, required: [name, type, tierId]}
    GeneratedFirewallRuleGroupBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/FirewallRuleGroup'}}}, required: [bulk]}
    FirewallRule: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, direction: {type: string, enum: [In, Out]}, action: {type: string, enum: [Permit, Deny]}, protocol: {type: string, enum: [ICMP, TCP, UDP]}, logging: {type: boolean}, ruleIndex: {type: number}, sourceAddressType: {type: string, enum: [IpAddress, NetworkObject, NetworkObjectGroup]}, sourceServiceType: {type: string, enum: [Port, ServiceObject, ServiceObjectGroup]}, destinationAddressType: {type: string, enum: [IpAddress, NetworkObject, NetworkObjectGroup]}, destinationServiceType: {type: string, enum: [Port, ServiceObject, ServiceObjectGroup]}, sourceIpAddress: {type: string}, sourceNetworkObjectId: {type: string}, sourceNetworkObjectGroupId: {type: string}, destinationIpAddress: {type: string}, destinationNetworkObjectId: {type: string}, destinationNetworkObjectGroupId: {type: string}, sourcePorts: {type: string}, sourceServiceObjectId: {type: string}, sourceServiceObjectGroupId: {type: string}, destinationPorts: {type: string}, destinationServiceObjectId: {type: string}, destinationServiceObjectGroupId: {type: string}, firewallRuleGroupId: {type: string}}, required: [name, direction, action, protocol, logging, ruleIndex, sourceAddressType, sourceServiceType, destinationAddressType, destinationServiceType, sourceIpAddress, sourceNetworkObjectId, sourceNetworkObjectGroupId, destinationIpAddress, destinationNetworkObjectId, destinationNetworkObjectGroupId, sourcePorts, sourceServiceObjectId, sourceServiceObjectGroupId, destinationPorts, destinationServiceObjectId, destinationServiceObjectGroupId, firewallRuleGroupId]}
    GeneratedFirewallRuleBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/FirewallRule'}}}, required: [bulk]}
    NetworkObject: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, type: {type: string}, ipAddress: {type: string}, endIpAddress: {type: string}, tierId: {type: string}}, required: [name, type, ipAddress, endIpAddress, tierId]}
    GeneratedNetworkObjectBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/NetworkObject'}}}, required: [bulk]}
    NetworkObjectGroup: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, tierId: {type: string}}, required: [name, tierId]}
    GeneratedNetworkObjectGroupBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/NetworkObjectGroup'}}}, required: [bulk]}
    ServiceObject: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, protocol: {type: string}, sourcePorts: {type: string}, destinationPorts: {type: string}, tierId: {type: string}}, required: [name, protocol, sourcePorts, destinationPorts, tierId]}
    GeneratedServiceObjectBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/ServiceObject'}}}, required: [bulk]}
    ServiceObjectGroup: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, tierId: {type: string}}, required: [name, tierId]}
    GeneratedServiceObjectGroupBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/ServiceObjectGroup'}}}, required: [bulk]}
    Vlan: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, vlanNumber: {type: number}, tierId: {type: string}}, required: [name, vlanNumber, tierId]}
    GeneratedVlanBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/Vlan'}}}, required: [bulk]}
    Subnet: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, network: {type: string}, gateway: {type: string}, vlanId: {type: string}, tierId: {type: string}}, required: [name, network, gateway, vlanId, tierId]}
    GeneratedSubnetBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/Subnet'}}}, required: [bulk]}
    StaticRoute: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, destinationNetwork: {type: string}, nextHop: {type: string}, metric: {type: number}, tierId: {type: string}}, required: [name, destinationNetwork, nextHop, metric, tierId]}
    GeneratedStaticRouteBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/StaticRoute'}}}, required: [bulk]}
    User: {type: object, properties: {}}
    VmwareVirtualMachine: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, cpuCores: {type: number}, cpuCoresPerSocket: {type: number}, cpuReserved: {type: boolean}, memorySize: {type: number}, memoryReserved: {type: boolean}}, required: [name, cpuCores, cpuCoresPerSocket, cpuReserved, memorySize, memoryReserved]}
    GeneratedVmwareVirtualMachineBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/VmwareVirtualMachine'}}}, required: [bulk]}
    VmwareNetworkAdapter: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, vlanId: {type: string}, virtualMachineId: {type: string}}, required: [name, vlanId, virtualMachineId]}
    GeneratedVmwareNetworkAdapterBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/VmwareNetworkAdapter'}}}, required: [bulk]}
    VmwareVirtualDisk: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, diskSize: {type: number}, rawLun: {type: boolean}, rawLunId: {type: number}, virtualMachineId: {type: string}}, required: [name, diskSize, rawLun, rawLunId, virtualMachineId]}
    GeneratedVmwareVirtualDiskBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/VmwareVirtualDisk'}}}, required: [bulk]}
    PhysicalServer: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, serialNumber: {type: string}, deliveryDate: {$ref: '#/definitions/Date'}, localStorageType: {type: string}, localStorageRequired: {type: boolean}, localStorageSize: {type: number}, sanType: {type: string}, sanRequired: {type: boolean}, sanStorageSize: {type: number}, datacenterId: {type: string}}, required: [name, serialNumber, deliveryDate, localStorageType, localStorageRequired, localStorageSize, sanType, sanRequired, sanStorageSize, datacenterId]}
    GeneratedPhysicalServerBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/PhysicalServer'}}}, required: [bulk]}
    Appliance: {type: object, properties: {id: {type: string}, createdAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, updatedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, version: {type: number, readOnly: true}, deletedAt: {title: Date, allOf: [{$ref: '#/definitions/Date'}, {readOnly: true}]}, name: {type: string}, description: {type: string}, rackUnits: {type: number}, serialNumber: {type: string}, deliveryDate: {$ref: '#/definitions/Date'}, localStorageType: {type: string}, localStorageRequired: {type: boolean}, localStorageSize: {type: number}, sanType: {type: string}, sanRequired: {type: boolean}, sanStorageSize: {type: number}, powerSupplyVoltage: {type: number}, powerSupplyWattage: {type: number}, powerSupplyConnectionType: {type: string}, powerSupplyCount: {type: number}, datacenterId: {type: string}}, required: [name, rackUnits, serialNumber, deliveryDate, localStorageType, localStorageRequired, localStorageSize, sanType, sanRequired, sanStorageSize, powerSupplyVoltage, powerSupplyWattage, powerSupplyConnectionType, powerSupplyCount, datacenterId]}
    GeneratedApplianceBulkDto: {type: object, properties: {bulk: {type: array, items: {$ref: '#/definitions/Appliance'}}}, required: [bulk]}
